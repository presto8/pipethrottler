#!/usr/bin/env python

# similar to cat except automatically throttles to keep CPU load beneath a specified level

# start cpu monitor in thread
# cpu monitor updates cpu load every 1 second
# start cat in main thread, read-write 4k chunks
# if cpu load is above threshold, throttle using binary exponential backoff algorithm

import sys, psutil, threading, time, random, argparse, math
import datetime

def debug(*args):
    print(*args, file=sys.stderr)

def get_ms():
    return int(round(time.time() * 1000))

def read_write_sleep(bufsize, secs):
    time_ms = secs * 1000
    start_ms = get_ms()
    buf = sys.stdin.buffer.read(bufsize)
    if buf == b'':
        return False
    sys.stdout.buffer.write(buf)
    elapsed_ms = get_ms() - start_ms
    need_ms = time_ms - elapsed_ms
    if need_ms > 0:
        time.sleep(need_ms/1000)
    return True

success_in_a_row = 0

def get_next_bufsize(cur_bufsize, curcpu, maxcpu):
    global success_in_a_row

    step = 10*1024
    if curcpu < maxcpu:
        success_in_a_row += 1
        if success_in_a_row >= 5:
            cur_bufsize += step
            success_in_a_row = 0
    elif curcpu > maxcpu:
        cur_bufsize -= step*5
        debug("cpu too high, throttling down", cur_bufsize, "xx")
    return cur_bufsize

def main(args):
    debug("starting pipethrottler with max CPU limit %d" % args.maxcpu)

    bufsize = args.startbs * 1024
    secs = 1

    try:
        while True:
            psutil.cpu_percent(interval=0) # call first to start measuring
            if not read_write_sleep(bufsize, secs):
                break
            cpu = psutil.cpu_percent(interval=0) # second call gets CPU use since previous call
            bufsize = get_next_bufsize(bufsize, cpu, args.maxcpu)
            debug("cpu", cpu, "bufsize", bufsize/1024, " ")
    except KeyboardInterrupt:
        pass

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--maxcpu', type=int, help='minimum CPU limit allowed before throttling begins', default=50)
    parser.add_argument('--startbs', type=int, help='starting bufsize in kb', default=100)
    p = parser.parse_args()
    return p

if __name__ == "__main__":
    args = parse_args()
    main(args)
